import { createSignal } from "solid-js"
import type { Instance, LogEntry } from "../types/instance"
import type { Permission } from "@opencode-ai/sdk"
import { sdkManager } from "../lib/sdk-manager"
import { sseManager } from "../lib/sse-manager"
import {
  fetchSessions,
  fetchAgents,
  fetchProviders,
  removeSessionIndexes,
  clearInstanceDraftPrompts,
} from "./sessions"
import { preferences, updateLastUsedBinary } from "./preferences"
import { setHasInstances } from "./ui"

const [instances, setInstances] = createSignal<Map<string, Instance>>(new Map())
const [activeInstanceId, setActiveInstanceId] = createSignal<string | null>(null)
const [instanceLogs, setInstanceLogs] = createSignal<Map<string, LogEntry[]>>(new Map())
const [logStreamingState, setLogStreamingState] = createSignal<Map<string, boolean>>(new Map())

// Permission queue management per instance
const [permissionQueues, setPermissionQueues] = createSignal<Map<string, Permission[]>>(new Map())
const [activePermissionId, setActivePermissionId] = createSignal<Map<string, string | null>>(new Map())
interface DisconnectedInstanceInfo {
  id: string
  folder: string
  reason: string
}
const [disconnectedInstance, setDisconnectedInstance] = createSignal<DisconnectedInstanceInfo | null>(null)

const MAX_LOG_ENTRIES = 1000

function ensureLogContainer(id: string) {
  setInstanceLogs((prev) => {
    if (prev.has(id)) {
      return prev
    }
    const next = new Map(prev)
    next.set(id, [])
    return next
  })
}

function ensureLogStreamingState(id: string) {
  setLogStreamingState((prev) => {
    if (prev.has(id)) {
      return prev
    }
    const next = new Map(prev)
    next.set(id, false)
    return next
  })
}

function removeLogContainer(id: string) {
  setInstanceLogs((prev) => {
    if (!prev.has(id)) {
      return prev
    }
    const next = new Map(prev)
    next.delete(id)
    return next
  })
  setLogStreamingState((prev) => {
    if (!prev.has(id)) {
      return prev
    }
    const next = new Map(prev)
    next.delete(id)
    return next
  })
}

function getInstanceLogs(instanceId: string): LogEntry[] {
  return instanceLogs().get(instanceId) ?? []
}

function isInstanceLogStreaming(instanceId: string): boolean {
  return logStreamingState().get(instanceId) ?? false
}

function setInstanceLogStreaming(instanceId: string, enabled: boolean) {
  ensureLogStreamingState(instanceId)
  setLogStreamingState((prev) => {
    const next = new Map(prev)
    next.set(instanceId, enabled)
    return next
  })
  if (!enabled) {
    clearLogs(instanceId)
  }
}

function addInstance(instance: Instance) {
  setInstances((prev) => {
    const next = new Map(prev)
    next.set(instance.id, instance)
    return next
  })
  ensureLogContainer(instance.id)
  ensureLogStreamingState(instance.id)
}

function updateInstance(id: string, updates: Partial<Instance>) {
  setInstances((prev) => {
    const next = new Map(prev)
    const instance = next.get(id)
    if (instance) {
      next.set(id, { ...instance, ...updates })
    }
    return next
  })
}

function removeInstance(id: string) {
  let nextActiveId: string | null = null

  setInstances((prev) => {
    if (!prev.has(id)) {
      return prev
    }

    const keys = Array.from(prev.keys())
    const index = keys.indexOf(id)
    const next = new Map(prev)
    next.delete(id)

    if (activeInstanceId() === id) {
      if (index > 0) {
        const prevKey = keys[index - 1]
        nextActiveId = prevKey ?? null
      } else {
        const remainingKeys = Array.from(next.keys())
        nextActiveId = remainingKeys.length > 0 ? (remainingKeys[0] ?? null) : null
      }
    }

    return next
  })

  removeLogContainer(id)

  if (activeInstanceId() === id) {
    setActiveInstanceId(nextActiveId)
  }

  // Clean up session indexes and drafts for removed instance
  removeSessionIndexes(id)
  clearInstanceDraftPrompts(id)
}

async function createInstance(folder: string, binaryPath?: string): Promise<string> {
  const id = `instance-${Date.now()}-${Math.random().toString(36).substr(2, 9)}`

  const instance: Instance = {
    id,
    folder,
    port: 0,
    pid: 0,
    status: "starting",
    client: null,
    environmentVariables: preferences().environmentVariables ?? {},
  }

  addInstance(instance)

  // Update last used binary
  if (binaryPath) {
    updateLastUsedBinary(binaryPath)
  }

  try {
    const {
      id: returnedId,
      port,
      pid,
      binaryPath: actualBinaryPath,
    } = await window.electronAPI.createInstance(id, folder, binaryPath, preferences().environmentVariables)

    const client = sdkManager.createClient(port)

    updateInstance(id, {
      port,
      pid,
      client,
      status: "ready",
      binaryPath: actualBinaryPath,
    })

    setActiveInstanceId(id)
    sseManager.connect(id, port)

    try {
      await fetchSessions(id)
      await fetchAgents(id)
      await fetchProviders(id)
    } catch (error) {
      console.error("Failed to fetch initial data:", error)
    }

    return id
  } catch (error) {
    updateInstance(id, {
      status: "error",
      error: error instanceof Error ? error.message : String(error),
    })
    throw error
  }
}

async function stopInstance(id: string) {
  const instance = instances().get(id)
  if (!instance) return

  sseManager.disconnect(id)

  if (instance.port) {
    sdkManager.destroyClient(instance.port)
  }

  if (instance.pid) {
    await window.electronAPI.stopInstance(instance.pid)
  }

  removeInstance(id)
}

function getActiveInstance(): Instance | null {
  const id = activeInstanceId()
  return id ? instances().get(id) || null : null
}

function addLog(id: string, entry: LogEntry) {
  if (!isInstanceLogStreaming(id)) {
    return
  }

  setInstanceLogs((prev) => {
    const next = new Map(prev)
    const existing = next.get(id) ?? []
    const updated = existing.length >= MAX_LOG_ENTRIES ? [...existing.slice(1), entry] : [...existing, entry]
    next.set(id, updated)
    return next
  })
}

function clearLogs(id: string) {
  setInstanceLogs((prev) => {
    if (!prev.has(id)) {
      return prev
    }
    const next = new Map(prev)
    next.set(id, [])
    return next
  })
}

// Permission management functions
function getPermissionQueue(instanceId: string): Permission[] {
  return permissionQueues().get(instanceId) ?? []
}

function getPermissionQueueLength(instanceId: string): number {
  return getPermissionQueue(instanceId).length
}

function addPermissionToQueue(instanceId: string, permission: Permission): void {
  setPermissionQueues((prev) => {
    const next = new Map(prev)
    const queue = next.get(instanceId) ?? []

    // Check if permission already exists
    if (queue.some(p => p.id === permission.id)) {
      return next // Don't add duplicate
    }

    // Add to queue and sort by creation time to maintain order
    const updatedQueue = [...queue, permission].sort((a, b) => a.time.created - b.time.created)
    next.set(instanceId, updatedQueue)
    return next
  })

  // Set as active if no active permission
  setActivePermissionId((prev) => {
    const next = new Map(prev)
    if (!next.get(instanceId)) {
      next.set(instanceId, permission.id)
    }
    return next
  })
}

function getActivePermission(instanceId: string): Permission | null {
  const activeId = activePermissionId().get(instanceId)
  if (!activeId) return null

  const queue = getPermissionQueue(instanceId)
  return queue.find(p => p.id === activeId) ?? null
}

function removePermissionFromQueue(instanceId: string, permissionId: string): void {
  let updatedQueue: Permission[] = []

  setPermissionQueues((prev) => {
    const next = new Map(prev)
    const queue = next.get(instanceId) ?? []
    updatedQueue = queue.filter(p => p.id !== permissionId)
    if (updatedQueue.length > 0) {
      next.set(instanceId, updatedQueue)
    } else {
      next.delete(instanceId)
    }
    return next
  })

  setActivePermissionId((prev) => {
    const next = new Map(prev)
    const activeId = next.get(instanceId)
    if (activeId === permissionId) {
      // Set the next permission in queue as active, or null if queue is empty
      const nextPermission = updatedQueue.length > 0 ? updatedQueue[0] : null
      next.set(instanceId, nextPermission?.id ?? null)
    }
    return next
  })
}

function clearPermissionQueue(instanceId: string): void {
  setPermissionQueues((prev) => {
    const next = new Map(prev)
    next.delete(instanceId)
    return next
  })
  setActivePermissionId((prev) => {
    const next = new Map(prev)
    next.delete(instanceId)
    return next
  })
}

async function sendPermissionResponse(
  instanceId: string,
  sessionId: string,
  permissionId: string,
  response: "once" | "always" | "reject"
): Promise<void> {
  const instance = instances().get(instanceId)
  if (!instance?.client) {
    throw new Error("Instance not ready")
  }

  try {
    await instance.client.postSessionIdPermissionsPermissionId({
      path: { id: sessionId, permissionID: permissionId },
      body: { response }
    })

    // Remove from queue after successful response
    removePermissionFromQueue(instanceId, permissionId)
  } catch (error) {
    console.error("Failed to send permission response:", error)
    throw error
  }
}

sseManager.onConnectionLost = (instanceId, reason) => {
  const instance = instances().get(instanceId)
  if (!instance) {
    return
  }

  setDisconnectedInstance({
    id: instanceId,
    folder: instance.folder,
    reason,
  })
}

async function acknowledgeDisconnectedInstance(): Promise<void> {
  const pending = disconnectedInstance()
  if (!pending) {
    return
  }

  try {
    await stopInstance(pending.id)
  } catch (error) {
    console.error("Failed to stop disconnected instance:", error)
  } finally {
    setDisconnectedInstance(null)
    if (instances().size === 0) {
      setHasInstances(false)
    }
  }
}

export {
  instances,
  activeInstanceId,
  setActiveInstanceId,
  addInstance,
  updateInstance,
  removeInstance,
  createInstance,
  stopInstance,
  getActiveInstance,
  addLog,
  clearLogs,
  instanceLogs,
  getInstanceLogs,
  isInstanceLogStreaming,
  setInstanceLogStreaming,
  // Permission management
  permissionQueues,
  activePermissionId,
  getPermissionQueue,
  getPermissionQueueLength,
  addPermissionToQueue,
  getActivePermission,
  removePermissionFromQueue,
  clearPermissionQueue,
  sendPermissionResponse,
  disconnectedInstance,
  acknowledgeDisconnectedInstance,
}
